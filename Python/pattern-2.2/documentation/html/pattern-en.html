<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
    <title>pattern-en</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <link type="text/css" rel="stylesheet" href="../clips.css" />
    <style>
        /* Small fixes because we omit the online layout.css. */
        h3 { line-height: 1.3em; }
        #page { margin-left: auto; margin-right: auto; }
        #header, #header-inner { height: 175px; }
        #header { border-bottom: 1px solid #C6D4DD;  }
        table { border-collapse: collapse; }
    </style>
</head>
<body class="node-type-page one-sidebar sidebar-right section-pages">
    <div id="page">
    <div id="page-inner">
    <div id="header"><div id="header-inner"></div></div>
    <div id="content">
    <div id="content-inner">
    <div class="node node-type-page"
        <div class="node-inner">
        <div class="breadcrumb">View online at: <a href="http://www.clips.ua.ac.be/pages/pattern-en" class="noexternal" target="_blank">http://www.clips.ua.ac.be/pages/pattern-en</a></div>
        <h1>pattern.en</h1>
        <!-- Parsed from the online documentation. -->
        <div id="node-1383" class="node node-type-page"><div class="node-inner">
<div class="content">
<h3>The pattern.en module contains a fast, regular expressions-based shallow parser (identifies nouns, adjectives, verbs, etc. in a sentence), a WordNet interface and tools for verb conjugation and noun singularization &amp; pluralization.</h3>
<p>It can be used by itself or with other <a href="pattern.html">pattern</a> modules: <a href="pattern-web.html">web</a> | <a href="pattern-db.html">db</a>&nbsp;| en | <a href="pattern-search.html">search</a> | <a href="pattern-vector.html">vector</a> | <a href="pattern-graph.html">graph</a>.</p>
<p><img src="../g/pattern_schema.gif" alt="" width="606" height="180" /></p>
<hr />
<h2>Documentation</h2>
<ul>
<li><a href="#article">Indefinite article</a></li>
<li><a href="#pluralization">Pluralization + singularization</a></li>
<li><a href="#comparative">Comparative + superlative</a></li>
<li><a href="#conjugation">Verb conjugation</a></li>
<li><a href="#quantify">Quantification</a></li>
<li><a href="#ngram">n-grams</a></li>
<li><a href="#parser">Parser</a>&nbsp;<span class="smallcaps link-maintenance">(tokenizer, tagger, chunker)</span></li>
<li><a href="#tree">Parse trees</a></li>
<li><a href="#sentiment">Sentiment</a></li>
<li><a href="#modality">Mood &amp; modality</a></li>
<li><a href="#wordnet">WordNet</a></li>
<li><a href="#wordlist">Wordlists</a></li>
</ul>
<p>&nbsp;</p>
<h2>
<hr /><a name="article"></a>Indefinite article</h2>
<p>The article is the most common determiner (<span class="postag">DT</span>) in English. It defines whether the noun following it is definite (<em><span style="text-decoration: underline;">the</span> cat</em>) or indefinite (<em><span style="text-decoration: underline;">a</span> cat</em>). The definite article is always <em>the</em>. The indefinite article can be either <em>a</em> or <em>an</em> – depending on how the successive noun is pronounced.</p>
<p><span class="geshifilter"><code class="python geshifilter-python">article<span style="">&#40;</span>word, function=INDEFINITE<span style="">&#41;</span> &nbsp; <span style="color: grey;"># DEFINITE | INDEFINITE</span></code></span><span class="geshifilter"><code class="python geshifilter-python">referenced<span style="">&#40;</span>word, article=INDEFINITE<span style="">&#41;</span> <span style="color: grey;"># Returns article + word.</span></code></span></p>
<p><span class="example"><span class="geshifilter"><code class="python geshifilter-python"><span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">from</span> pattern.<span style="">en</span> <span style="color: #28334f; font-weight: bold;">import</span> referenced<br />
<span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">print</span> referenced<span style="">&#40;</span><span style="color: #657a8a;">'university'</span><span style="">&#41;</span><br />
<span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">print</span> referenced<span style="">&#40;</span><span style="color: #657a8a;">'hour'</span><span style="">&#41;</span><br />
<br />
a university<br />
an hour</code></span></span></p>
<p><span class="small"><span style="text-decoration: underline;">Reference</span>: Granger, M. (2006). <em>Ruby Linguistics Framework</em>, </span><span class="small">http://deveiate.org/projects/Linguistics</span></p>
<p>&nbsp;</p>
<hr />
<h2><a name="pluralization"></a>Pluralization + singularization</h2>
<p>The <span class="inline_code">pluralize()</span> command returns the singular form of a plural noun. It handles 96% of exceptions correctly. The <span class="inline_code">singularize()</span> command returns the plural form of a singular noun. The <span class="inline_code">pos</span> parameter (part-of-speech) can be set to <span class="inline_code">NOUN</span> or <span class="inline_code">ADJECTIVE</span>, but only a small number of possessive adjectives inflect (e.g. <em>my</em> → <em>our</em>). The <span class="inline_code">custom</span> dictionary is for user-defined replacements.</p>
<p><span class="geshifilter"><code class="python geshifilter-python">pluralize<span style="">&#40;</span>word, pos=NOUN, custom=<span style="">&#123;</span><span style="">&#125;</span>, classical=<span style="color: #4a587c;">True</span><span style="">&#41;</span></code></span><span class="geshifilter"><code class="python geshifilter-python">singularize<span style="">&#40;</span>word, pos=NOUN, custom=<span style="">&#123;</span><span style="">&#125;</span><span style="">&#41;</span></code></span></p>
<p><span class="example"><span class="geshifilter"><code class="python geshifilter-python"><span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">from</span> pattern.<span style="">en</span> <span style="color: #28334f; font-weight: bold;">import</span> pluralize, singularize<br />
<span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">print</span> pluralize<span style="">&#40;</span><span style="color: #657a8a;">'child'</span><span style="">&#41;</span><br />
<span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">print</span> singularize<span style="">&#40;</span><span style="color: #657a8a;">'wolves'</span><span style="">&#41;</span><br />
<br />
children<br />
wolves</code></span></span></p>
<p><span class="small"><span style="text-decoration: underline;">Reference</span>: <br />Conway, D. (1998). <em>An Algorithmic Approach to English Pluralization</em>.<br />Ferrer, B. (2005). <em>Inflector for Python</em>, http://www.bermi.org/projects/inflector</span></p>
<p>&nbsp;</p>
<hr />
<h2><a name="comparative"></a>Comparative + superlative</h2>
<p>The <span class="inline_code">comparative()</span> and <span class="inline_code">superlative()</span> commands give the comparative or superlative form of an adjective. Words with three or more syllables are simply preceded by <em>more</em> or <em>most</em>.</p>
<p><span class="geshifilter"><code class="python geshifilter-python">comparative<span style="">&#40;</span>adjective<span style="">&#41;</span> &nbsp; &nbsp; &nbsp;<span style="color: grey;"># big =&gt; bigger</span></code></span><span class="geshifilter"><code class="python geshifilter-python">superlative<span style="">&#40;</span>adjective<span style="">&#41;</span> &nbsp; &nbsp; &nbsp;<span style="color: grey;"># big =&gt; biggest</span></code></span><span class="example"><span class="geshifilter"><code class="python geshifilter-python"><span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">from</span> pattern.<span style="">en</span> <span style="color: #28334f; font-weight: bold;">import</span> comparative, superlative<br />
<span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">print</span> comparative<span style="">&#40;</span><span style="color: #657a8a;">'bad'</span><span style="">&#41;</span><br />
<span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">print</span> superlative<span style="">&#40;</span><span style="color: #657a8a;">'bad'</span><span style="">&#41;</span><br />
<br />
worse<br />
worst</code></span></span></p>
<p>&nbsp;</p>
<hr />
<h2><a name="conjugation"></a>Verb conjugation</h2>
<p>The <span class="inline_code">pattern.en</span> module has a lexicon of 8,500 common English verbs and their conjugated forms (infinitive, 3rd singular present, present participle, past and past participle – verbs such as <em>be</em> have other forms as well). The following verbs can be negated: <em>be</em>, <em>can</em>, <em>do</em>, <em>will</em>, <em>must</em>, <em>have</em>, <em>may</em>, <em>need</em>, <em>dare</em>, <em>ought</em>.</p>
<p><span class="geshifilter"><code class="python geshifilter-python">conjugate<span style="">&#40;</span>verb, tense=INFINITIVE, negated=<span style="color: #4a587c;">False</span><span style="">&#41;</span></code></span><span class="geshifilter"><code class="python geshifilter-python">lemma<span style="">&#40;</span>verb<span style="">&#41;</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: grey;"># Base form, e.g. are =&gt; be.</span></code></span><span class="geshifilter"><code class="python geshifilter-python">lexeme<span style="">&#40;</span>verb<span style="">&#41;</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: grey;"># List of possible forms: be =&gt; is, was, ...</span></code></span><span class="geshifilter"><code class="python geshifilter-python">tenses<span style="">&#40;</span>verb<span style="">&#41;</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: grey;"># List of possible tenses of the given form.</span></code></span></p>
<p>The <span class="inline_code">tense</span> parameter of the <span class="inline_code">conjugate()</span> command can be set to the following values:</p>
<table class="border">
<tbody>
<tr>
<td><span class="smallcaps">Tense</span></td>
<td style="text-align: center;"><span class="smallcaps">Alias</span></td>
<td style="text-align: center;"><span class="smallcaps">Tag</span></td>
<td><span class="smallcaps">Example</span></td>
</tr>
<tr>
<td><span class="inline_code">INFINITIVE</span></td>
<td style="text-align: center;"><span class="inline_code">"inf"</span></td>
<td style="text-align: center;"><span class="postag">VB</span></td>
<td><em>be</em></td>
</tr>
<tr>
<td><span class="inline_code">PRESENT_1ST_PERSON_SINGULAR</span></td>
<td style="text-align: center;"><span class="inline_code">"1sg"</span></td>
<td style="text-align: center;"><span class="postag">VBP</span></td>
<td><em>I <span style="text-decoration: underline;">am</span></em></td>
</tr>
<tr>
<td><span class="inline_code">PRESENT_2ND_PERSON_SINGULAR</span></td>
<td style="text-align: center;"><span class="inline_code">"2sg"</span></td>
<td style="text-align: center;">&nbsp;·</td>
<td><em>you <span style="text-decoration: underline;">are</span></em></td>
</tr>
<tr>
<td><span class="inline_code">PRESENT_3RD_PERSON_SINGULAR</span></td>
<td style="text-align: center;"><span class="inline_code">"3sg"</span></td>
<td style="text-align: center;"><span class="postag">VBZ</span></td>
<td><em>he <span style="text-decoration: underline;">is</span></em></td>
</tr>
<tr>
<td><span class="inline_code">PRESENT_PLURAL</span></td>
<td style="text-align: center;"><span class="inline_code">"pl"</span></td>
<td style="text-align: center;">&nbsp;·</td>
<td><em>we <span style="text-decoration: underline;">are</span></em></td>
</tr>
<tr>
<td><span class="inline_code">PRESENT_PARTICIPLE</span></td>
<td style="text-align: center;"><span class="inline_code">"part"</span></td>
<td style="text-align: center;"><span class="postag">VBG</span></td>
<td><em>being</em></td>
</tr>
<tr>
<td><span class="inline_code">PAST</span></td>
<td style="text-align: center;"><span class="inline_code">"p"</span></td>
<td style="text-align: center;"><span class="postag">VBD</span></td>
<td><em>were</em></td>
</tr>
<tr>
<td><span class="inline_code">PAST_1ST_PERSON_SINGULAR</span></td>
<td style="text-align: center;"><span class="inline_code">"1sgp"</span></td>
<td style="text-align: center;">&nbsp;·</td>
<td><em>I <span style="text-decoration: underline;">was</span></em></td>
</tr>
<tr>
<td><span class="inline_code">PAST_2ND_PERSON_SINGULAR</span></td>
<td style="text-align: center;"><span class="inline_code">"2sgp"</span></td>
<td style="text-align: center;">&nbsp;·</td>
<td><em>you <span style="text-decoration: underline;">were</span></em></td>
</tr>
<tr>
<td><span class="inline_code">PAST_3RD_PERSON_SINGULAR</span></td>
<td style="text-align: center;"><span class="inline_code">"3gp"</span></td>
<td style="text-align: center;">&nbsp;·</td>
<td><em>he <span style="text-decoration: underline;">was</span></em></td>
</tr>
<tr>
<td><span class="inline_code">PAST_PLURAL</span></td>
<td style="text-align: center;"><span class="inline_code">"ppl"</span></td>
<td style="text-align: center;">&nbsp;·</td>
<td><em>we <span style="text-decoration: underline;">were</span></em></td>
</tr>
<tr>
<td><span class="inline_code">PAST_PARTICIPLE</span></td>
<td style="text-align: center;"><span class="inline_code">"ppart"</span></td>
<td style="text-align: center;"><span class="postag">VBN</span></td>
<td><span style="text-decoration: underline;">been</span></td>
</tr>
</tbody>
</table>
<p>For example:</p>
<p><span class="example"><span class="geshifilter"><code class="python geshifilter-python"><span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">from</span> pattern.<span style="">en</span> <span style="color: #28334f; font-weight: bold;">import</span> conjugate, lemma, lexeme, tenses, PAST<br />
<span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">print</span> lexeme<span style="">&#40;</span><span style="color: #657a8a;">'purr'</span><span style="">&#41;</span><br />
<span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">print</span> lemma<span style="">&#40;</span><span style="color: #657a8a;">'purring'</span><span style="">&#41;</span><br />
<span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">print</span> conjugate<span style="">&#40;</span><span style="color: #657a8a;">'purred'</span>, tense=<span style="color: #657a8a;">'3sg'</span><span style="">&#41;</span><br />
<span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">print</span> PAST <span style="color: #28334f; font-weight: bold;">in</span> tenses<span style="">&#40;</span><span style="color: #657a8a;">&quot;purred&quot;</span><span style="">&#41;</span> <span style="color: grey;"># 'p' in tenses() will also work.</span><br />
<br />
<span style="">&#91;</span><span style="color: #657a8a;">'purr'</span>, <span style="color: #657a8a;">'purrs'</span>, <span style="color: #657a8a;">'purring'</span>, <span style="color: #657a8a;">'purred'</span><span style="">&#93;</span><br />
purr<br />
purrs<br />
<span style="color: #4a587c;">True</span></code></span></span></p>
<p><span class="small"><span style="text-decoration: underline;">Reference</span>: <em>XTAG English morphology</em> (1999), University of Pennsylvania, http://www.cis.upenn.edu/~xtag</span></p>
<p>&nbsp;</p>
<p><span class="smallcaps">Rule-based conjugation</span></p>
<p>All of the verb commands have an optional <span class="inline_code">parse=True</span> parameter that enables a rule-based parser for unknown verbs. This will not work for irregular verbs however, and it is fragile for verbs ending in -e in the past tense or as present participle (overall accuracy 91%).</p>
<p>With <span class="inline_code">parse=False</span>,&nbsp;<span class="inline_code" style="font-family: Courier, monospace; font-size: 12px;">conjugate()</span>&nbsp;and&nbsp;<span class="inline_code" style="font-family: Courier, monospace; font-size: 12px;">lemma()</span>&nbsp;yield&nbsp;<span class="inline_code" style="font-family: Courier, monospace; font-size: 12px;">None</span>.</p>
<p><span class="example"><span class="geshifilter"><code class="python geshifilter-python"><span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">from</span> pattern.<span style="">en</span> <span style="color: #28334f; font-weight: bold;">import</span> conjugate, VERBS<br />
<span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">print</span> <span style="color: #657a8a;">'facebooked'</span> <span style="color: #28334f; font-weight: bold;">in</span> VERBS<br />
<span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">print</span> conjugate<span style="">&#40;</span><span style="color: #657a8a;">'facebooked'</span>, tense=<span style="color: #657a8a;">'part'</span>, parse=<span style="color: #4a587c;">False</span><span style="">&#41;</span><br />
<span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">print</span> conjugate<span style="">&#40;</span><span style="color: #657a8a;">'facebooked'</span>, tense=<span style="color: #657a8a;">'part'</span>, parse=<span style="color: #4a587c;">True</span><span style="">&#41;</span><br />
<br />
<span style="color: #4a587c;">False</span><br />
<span style="color: #4a587c;">None</span><br />
facebooking</code></span></span></p>
<p>&nbsp;</p>
<hr />
<h2><a name="quantify"></a>Quantification</h2>
<p>The <span class="inline_code">number()</span> command returns a <span class="inline_code">float</span> or <span class="inline_code">int</span> parsed from the given (numeric) string. If no number can be parsed from the string, it returns <span class="inline_code">0</span>.</p>
<p>The <span class="inline_code">numerals()</span> command returns the given <span class="inline_code">int</span> or <span class="inline_code">float</span> as a string of numerals. By default, the fractional part is rounded to two decimals. Because of rounding <span class="inline_code">float(number(x)) == x</span> is not always <span class="inline_code">True</span>.</p>
<p>The <span class="inline_code">quantify()</span> command returns a wordcount approximation. Two similar words are a <em>pair</em>, three to eight <em>several</em>, and so on. Words can be given as a list, a word → count dictionary, or a string + amount.</p>
<p>The <span class="inline_code">reflect()</span> command quantifies Python objects – see the examples bundled with the module.</p>
<p><span class="geshifilter"><code class="python geshifilter-python">number<span style="">&#40;</span><span style="">string</span><span style="">&#41;</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: grey;"># &quot;seventy-five point two&quot; =&gt; 75.2</span></code></span><span class="geshifilter"><code class="python geshifilter-python">numerals<span style="">&#40;</span>n, <span style="color: #4a587c;">round</span>=<span style="color: #666;">2</span><span style="">&#41;</span> &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: grey;"># 2.245 =&gt; &quot;two point twenty-five&quot;</span></code></span></p>
<p><span class="geshifilter"><code class="python geshifilter-python">quantify<span style="">&#40;</span><span style="">&#91;</span>word1, word2, ...<span style="">&#93;</span>, plural=<span style="">&#123;</span><span style="">&#125;</span><span style="">&#41;</span></code></span><span class="geshifilter"><code class="python geshifilter-python">reflect<span style="">&#40;</span><span style="color: #4a587c;">object</span>, quantify=<span style="color: #4a587c;">True</span>, replace=<span style="">&#91;</span><span style="">&#93;</span><span style="">&#41;</span></code></span></p>
<p><span class="example"><span class="geshifilter"><code class="python geshifilter-python"><span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">from</span> pattern.<span style="">en</span> <span style="color: #28334f; font-weight: bold;">import</span> quantify<br />
<span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">print</span> quantify<span style="">&#40;</span><span style="">&#91;</span><span style="color: #657a8a;">'goose'</span>, <span style="color: #657a8a;">'goose'</span>, <span style="color: #657a8a;">'duck'</span>, <span style="color: #657a8a;">'chicken'</span>, <span style="color: #657a8a;">'chicken'</span>, <span style="color: #657a8a;">'chicken'</span><span style="">&#93;</span><span style="">&#41;</span><br />
<span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">print</span> quantify<span style="">&#40;</span><span style="color: #657a8a;">'carrot'</span>, amount=<span style="color: #666;">1000</span><span style="">&#41;</span><br />
<span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">print</span> quantify<span style="">&#40;</span><span style="">&#123;</span><span style="color: #657a8a;">'carrot'</span>: <span style="color: #666;">100</span>, <span style="color: #657a8a;">'parrot'</span>: <span style="color: #666;">20</span><span style="">&#125;</span><span style="">&#41;</span><br />
<br />
several chickens, a pair of geese a​nd a duck<br />
hundreds of carrots<br />
dozens of carrots a​nd a score of parrots</code></span></span></p>
<p>&nbsp;</p>
<h2>
<hr /><em><a name="ngram"></a>n</em>-grams</h2>
<p>The <span class="inline_code">ngrams()</span> command returns&nbsp;a list of <em>n</em>-grams (i.e., tuples of <em>n</em> successive words) from the given string.&nbsp;Alternatively, you can supply a <span class="inline_code">Text</span> or <span class="inline_code">Sentence</span> object (see further).&nbsp;<em>n</em>-grams will not run over sentence markers (i.e., .!?).</p>
<p><span class="geshifilter"><code class="python geshifilter-python">ngrams<span style="">&#40;</span><span style="">string</span>, n=<span style="color: #666;">3</span><span style="">&#41;</span></code></span></p>
<p><span class="example"><span class="geshifilter"><code class="python geshifilter-python"><span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">print</span> ngrams<span style="">&#40;</span><span style="color: #657a8a;">&quot;I am eating a pizza.&quot;</span>, n=<span style="color: #666;">3</span><span style="">&#41;</span><br />
<br />
<span style="">&#91;</span><span style="">&#40;</span><span style="color: #657a8a;">'I'</span>, <span style="color: #657a8a;">'am'</span>, <span style="color: #657a8a;">'eating'</span><span style="">&#41;</span>, <span style="">&#40;</span><span style="color: #657a8a;">'am'</span>, <span style="color: #657a8a;">'eating'</span>, <span style="color: #657a8a;">'a'</span><span style="">&#41;</span>, <span style="">&#40;</span><span style="color: #657a8a;">'eating'</span>, <span style="color: #657a8a;">'a'</span>, <span style="color: #657a8a;">'pizza'</span><span style="">&#41;</span><span style="">&#93;</span> </code></span></span></p>
<p>&nbsp;</p>
<hr />
<h2><a name="parser"></a>Parser</h2>
<p>The core of the <span class="inline_code">pattern.en</span> module is a rule-based shallow parser. To a machine, a text document is nothing more than a string of characters. A shallow parser adds <strong>meaning</strong> by distinguishing between abbreviation periods and sentence breaks, by adding part-of-speech tags to words (is <em>can</em> in this sentence a <span class="postag">NOUN</span> or a <span class="postag">VERB</span>?) and by grouping words that belong together (chunking).</p>
<p>The parser uses a regular expressions-based approach, which is <strong>fast</strong> but not always accurate. The <span class="inline_code">parse()</span> command and the <span class="inline_code">Text</span>, <span class="inline_code">Sentence</span>, <span class="inline_code">Chunk</span> and <span class="inline_code">Word</span> objects (discussed in the next section) are identical to those in <a href="http://www.clips.ua.ac.be/pages/MBSP" target="_blank">MBSP</a> – a shallow parser that uses a statistical machine learning approach. It is more robust, but slower. Output from both parsers can be used in the <span class="inline_code">pattern.search</span> and <span class="inline_code">pattern.vector</span> modules.</p>
<p>The <span class="inline_code">parse()</span> command takes a string of text and returns a tagged Unicode string. <br />Sentences in the output are separated by newline characters.</p>
<p><span class="geshifilter"><code class="python geshifilter-python">parse<span style="">&#40;</span><span style="">string</span>, <br />
&nbsp; &nbsp;<span style="">tokenize</span> = <span style="color: #4a587c;">True</span>, &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: grey;"># Separate punctuation from words?</span><br />
&nbsp; &nbsp; &nbsp; &nbsp;tags = <span style="color: #4a587c;">True</span>, &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: grey;"># Parse part-of-speech tags? (NN, JJ, ...)</span><br />
&nbsp; &nbsp; &nbsp;chunks = <span style="color: #4a587c;">True</span>, &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: grey;"># Parse chunks? (NP, VP, PNP, ...)</span><br />
&nbsp; relations = <span style="color: #4a587c;">False</span>, &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: grey;"># Find relations? (SBJ, OBJ, ...)</span><br />
&nbsp; &nbsp; lemmata = <span style="color: #4a587c;">False</span>, &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: grey;"># Find word lemmata? (ate =&gt; eat)</span><br />
&nbsp; &nbsp;encoding = <span style="color: #657a8a;">'utf-8'</span>, &nbsp; &nbsp; &nbsp;<span style="color: grey;"># Default string encoding?</span><br />
&nbsp; &nbsp; default = <span style="color: #657a8a;">'NN'</span>, &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: grey;"># Default part-of-speech tag.</span><br />
&nbsp; &nbsp; &nbsp; light = <span style="color: #4a587c;">False</span><span style="">&#41;</span> &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: grey;"># True =&gt; disables contextual rules.</span></code></span></p>
<p>For example:</p>
<p><span class="example"><span class="geshifilter"><code class="python geshifilter-python"><span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">from</span> pattern.<span style="">en</span> <span style="color: #28334f; font-weight: bold;">import</span> parse<br />
<span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">print</span> parse<span style="">&#40;</span><span style="color: #657a8a;">'I eat pizza with a fork.'</span><span style="">&#41;</span><br />
<br />
I/PRP/B-NP/O eat/VBD/B-VP pizza/NN/B-NP/O with/IN/B-PP/B-PNP a/DT/B-NP/I-PNP fork/NN/I-NP/I-PNP ././O/O</code></span></span></p>
<p>Each token (i.e. tagged word) in a sentence has a number of annotations: <span class="inline_code">tags</span><span class="inline_code">=True</span> includes the word part-of-speech tag, <span class="inline_code">chunks=True</span> the chunk tag + <span class="postag">PNP</span> tag (prepositional noun phrase). With <span class="inline_code">tokenize</span> set to <span class="inline_code">False</span>, no tokenization is carried out (the input string is expected to be tokenized). The <span class="inline_code">encoding</span> parameter defines the character encoding of the input string.</p>
<p>The parser is built on a Brill lexicon of tagged words and rules to improve the tags context-wise. With <span class="inline_code">light=False</span>, it uses Brill's contextual rules. With <span class="inline_code">light=True</span> it uses Jason Wiener's simpler ruleset. This ruleset is 5-10x faster but also 25% less accurate.</p>
<p><span class="small"><span style="text-decoration: underline;">Reference</span>: Brill, E. (1992). <em>A simple rule-based part of speech tagger.</em> ANLC '92 Proceedings.</span></p>
<h3>Parser tags</h3>
<p>Let's examine the word <em>fork</em> and the tags assigned by the parser in the example above:</p>
<table class="border">
<tbody>
<tr>
<td class="smallcaps" style="text-align: center;" align="center">word</td>
<td class="smallcaps" style="text-align: center;" align="center">part-of-speech</td>
<td class="smallcaps" style="text-align: center;" align="center">chunk</td>
<td class="smallcaps" style="text-align: center;" align="center">pnp</td>
</tr>
<tr>
<td align="center">fork</td>
<td align="center"><span class="postag">NN </span></td>
<td align="center"><span class="postag">I-NP</span></td>
<td align="center"><span class="postag">I-PNP</span></td>
</tr>
</tbody>
</table>
<p>The word's part-of-speech tag is <span class="postag">NN</span>, which means that it is a noun. The word occurs in a <span class="postag">NP</span> chunk, a noun phrase (<em>a fork</em>). It is also part of a prepositional noun phrase (<em>with a fork</em>).</p>
<p>Common part-of-speech tags include <span class="postag">NN</span> (noun), <span class="postag">JJ</span> (adjective) and <span class="postag">VB</span> (verb).<br />Common chunk tags include <span class="postag">NP</span> (noun phrase) and <span class="postag">VP</span> (verb phrase).<br />Common relations include <span class="postag">SBJ</span> (subject) and <span class="postag">OBJ</span> (object).</p>
<p>The <a href="MBSP-tags.html" target="_blank">Penn Treebank II tags</a> page gives an overview of all the possible tags generated by the parser.</p>
<h3>Parser shortcuts</h3>
<p>The <span class="inline_code">tag()</span> command returns a list of <span class="inline_code">(word, POStag)</span>-tuples. With <span class="inline_code">light=True</span>, this is the fastest and simplest way to get an idea of a sentence's constituents.</p>
<p><span class="geshifilter"><code class="python geshifilter-python">tag<span style="">&#40;</span><span style="">string</span>, <span style="">tokenize</span>=<span style="color: #4a587c;">True</span>, encoding=<span style="color: #657a8a;">'utf-8'</span>, default=<span style="color: #657a8a;">'NN'</span>, light=<span style="color: #4a587c;">False</span><span style="">&#41;</span></code></span></p>
<p><span class="example"><span class="geshifilter"><code class="python geshifilter-python"><span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">from</span> pattern.<span style="">en</span> <span style="color: #28334f; font-weight: bold;">import</span> tag<br />
<span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">for</span> word, tag <span style="color: #28334f; font-weight: bold;">in</span> tag<span style="">&#40;</span><span style="color: #657a8a;">'The cat felt happy.'</span>, light=<span style="color: #4a587c;">True</span><span style="">&#41;</span>:<br />
<span style="">&gt;&gt;&gt;</span> &nbsp; &nbsp; <span style="color: #28334f; font-weight: bold;">if</span> tag == <span style="color: #657a8a;">&quot;JJ&quot;</span>: <span style="color: grey;"># Retrieve all adjectives from the input string.</span><br />
<span style="">&gt;&gt;&gt;</span> &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #28334f; font-weight: bold;">print</span> word<br />
<br />
happy</code></span></span></p>
<h3>Parser output</h3>
<p>The output of the <span class="inline_code">parse()</span> command is a string of sentences in which each token has been annotated with the requested tags. The <span class="inline_code">pprint()</span> command (extra <em>p</em> is for <em>pretty</em>) gives a good overview of the tags:</p>
<p><span class="example"><span class="geshifilter"><code class="python geshifilter-python"><span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">from</span> pattern.<span style="">en</span> <span style="color: #28334f; font-weight: bold;">import</span> parse, <span style="">pprint</span><br />
<span style="">&gt;&gt;&gt;</span> s = parse<span style="">&#40;</span><span style="color: #657a8a;">'I ate pizza.'</span>, relations=<span style="color: #4a587c;">True</span>, lemmata=<span style="color: #4a587c;">True</span><span style="">&#41;</span><br />
<span style="">&gt;&gt;&gt;</span> <span style="">pprint</span><span style="">&#40;</span>s<span style="">&#41;</span> <br />
<br />
&nbsp; &nbsp; WORD &nbsp; TAG &nbsp; &nbsp;CHUNK &nbsp; ROLE &nbsp; ID &nbsp; &nbsp; PNP &nbsp; &nbsp;LEMMA<br />
&nbsp; &nbsp; &nbsp; &nbsp;I &nbsp; PRP &nbsp; &nbsp;NP &nbsp; &nbsp; &nbsp;SBJ &nbsp; &nbsp;<span style="color: #666;">1</span> &nbsp; &nbsp; &nbsp;- &nbsp; &nbsp; &nbsp;i &nbsp; <br />
&nbsp; &nbsp; &nbsp;ate &nbsp; VBP &nbsp; &nbsp;VP &nbsp; &nbsp; &nbsp;- &nbsp; &nbsp; &nbsp;<span style="color: #666;">1</span> &nbsp; &nbsp; &nbsp;- &nbsp; &nbsp; &nbsp;eat &nbsp; &nbsp; &nbsp; &nbsp; <br />
&nbsp; &nbsp;pizza &nbsp; NN &nbsp; &nbsp; NP &nbsp; &nbsp; &nbsp;OBJ &nbsp; &nbsp;<span style="color: #666;">1</span> &nbsp; &nbsp; &nbsp;- &nbsp; &nbsp; &nbsp;pizza &nbsp; &nbsp; &nbsp; &nbsp; <br />
&nbsp; &nbsp; &nbsp; &nbsp;. &nbsp; . &nbsp; &nbsp; &nbsp;- &nbsp; &nbsp; &nbsp; - &nbsp; &nbsp; &nbsp;- &nbsp; &nbsp; &nbsp;- &nbsp; &nbsp; &nbsp;. &nbsp; &nbsp; &nbsp; &nbsp;</code></span></span></p>
<p>The output string is a <span class="inline_code">TaggedString</span> object that behaves as a Python string, but with a <span class="inline_code">TaggedString.split()</span> method that yields (without parameters) a list of sentences, where each sentence is a list of tokens,  in which each token is a list of the word + its tags.</p>
<p>If  you want to analyze the output (i.e. examine the relations between  words and groups of words), the most convenient way is to construct a <a href="#tree" target="_self">parse tree</a> from the output.</p>
<p>&nbsp;</p>
<hr />
<h2><a name="tree"></a>Parse trees</h2>
<p>A parse tree stores a tagged string as a network of linked Python  objects that can be traversed to analyze the constituents in the text.  The output of the <a href="#parser" target="_self">parser</a> can be passed to the <span class="inline_code">split()</span> command, which produces a <span class="inline_code">Text</span> object. Essentially, a <span class="inline_code">Text</span> is a list of <span class="inline_code">Sentence</span> objects. Each <span class="inline_code">Sentence</span> consists of <span class="inline_code">Word</span> objects. <span class="inline_code">Word</span> objects are also grouped in <span class="inline_code">Chunk</span> objects, which are related to other <span class="inline_code">Chunk</span> objects in various ways.</p>
<p><span class="geshifilter"><code class="python geshifilter-python">split<span style="">&#40;</span>taggedstring, <span style="">token</span>=<span style="">&#91;</span>WORD, POS, CHUNK, PNP<span style="">&#93;</span><span style="">&#41;</span></code></span></p>
<p>We'll run the sentence "<em>The cat sat on the mat.</em>" through the parse tree:</p>
<p><span class="example"><span class="geshifilter"><code class="python geshifilter-python"><span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">from</span> pattern.<span style="">en</span> <span style="color: #28334f; font-weight: bold;">import</span> parse, split<br />
<span style="">&gt;&gt;&gt;</span> s = parse<span style="">&#40;</span><span style="color: #657a8a;">'The cat sat on the mat.'</span>, relations=<span style="color: #4a587c;">True</span>, lemmata=<span style="color: #4a587c;">True</span><span style="">&#41;</span><br />
<span style="">&gt;&gt;&gt;</span> s = split<span style="">&#40;</span>s<span style="">&#41;</span><br />
<span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">print</span> <span style="color: #4a587c;">repr</span><span style="">&#40;</span>s<span style="">&#41;</span><br />
<br />
<span style="">&#91;</span>Sentence<span style="">&#40;</span><br />
&nbsp;<span style="color: #657a8a;">'The/DT/B-NP/O/NP-SBJ-1/the <br />
&nbsp; cat/NN/I-NP/O/NP-SBJ-1/cat <br />
&nbsp; sat/VBD/B-VP/O/VP-1/sit <br />
&nbsp; on/IN/B-PP/B-PNP/O/on <br />
&nbsp; the/DT/B-NP/I-PNP/O/the <br />
&nbsp; mat/NN/I-NP/I-PNP/O/mat <br />
&nbsp; ././O/O/O/O/.'</span><span style="">&#41;</span><span style="">&#93;</span></code></span><span class="geshifilter"><code class="python geshifilter-python"><span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">print</span> s<span style="">&#91;</span><span style="color: #666;">0</span><span style="">&#93;</span>.<span style="">chunks</span><br />
<br />
<span style="">&#91;</span>Chunk<span style="">&#40;</span><span style="color: #657a8a;">'The cat/NP-SBJ-1'</span><span style="">&#41;</span>, <br />
&nbsp;Chunk<span style="">&#40;</span><span style="color: #657a8a;">'sat/VP-1'</span><span style="">&#41;</span>, <br />
&nbsp;Chunk<span style="">&#40;</span><span style="color: #657a8a;">'on/PP'</span><span style="">&#41;</span>, <br />
&nbsp;Chunk<span style="">&#40;</span><span style="color: #657a8a;">'the mat/NP'</span><span style="">&#41;</span><span style="">&#93;</span></code></span></span></p>
<h3>Text</h3>
<p>A <span class="inline_code">Text</span> is a list of <span class="inline_code">Sentence</span> objects (i.e. you can do: <span class="inline_code">for sentence in text</span>).</p>
<p><span class="geshifilter"><code class="python geshifilter-python">text = Text<span style="">&#40;</span>taggedstring<span style="">&#41;</span></code></span><span class="geshifilter"><code class="python geshifilter-python">text = Text.<span style="">from_xml</span><span style="">&#40;</span><span style="">xml</span><span style="">&#41;</span> &nbsp;<span style="color: grey;"># Reads an XML-string generated with Text.xml.</span></code></span><span class="geshifilter"><code class="python geshifilter-python">text.<span style="">string</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: grey;"># 'The cat sat on the mat .'</span><br />
text.<span style="">sentences</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: grey;"># [Sentence('The cat sat on the mat .')]</span><br />
text.<span style="">copy</span><span style="">&#40;</span><span style="">&#41;</span><br />
text.<span style="">xml</span></code></span></p>
<h3>Sentence</h3>
<p>A <span class="inline_code">Sentence</span> is a list of <span class="inline_code">Word</span> objects, with attributes + methods that organize words in <span class="inline_code">Chunk</span> objects.</p>
<p><span class="geshifilter"><code class="python geshifilter-python">sentence = Sentence<span style="">&#40;</span>taggedstring<span style="">&#41;</span></code></span><span class="geshifilter"><code class="python geshifilter-python">sentence = Sentence.<span style="">from_xml</span><span style="">&#40;</span><span style="">xml</span><span style="">&#41;</span> </code></span><span class="geshifilter"><code class="python geshifilter-python">sentence.<span style="">parent</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: grey;"># Sentence parent (for a Slice), or None.</span><br />
sentence.<span style="color: #4a587c;">id</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: grey;"># Unique for each sentence.</span><br />
sentence.<span style="">start</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: grey;"># 0</span><br />
sentence.<span style="">stop</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: grey;"># Sentence length.</span></code></span><span class="geshifilter"><code class="python geshifilter-python">sentence.<span style="">string</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: grey;"># Tokenized string, without tags.</span><br />
sentence.<span style="">words</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: grey;"># List of Word objects.</span><br />
sentence.<span style="">chunks</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: grey;"># List of Chunk objects.</span><br />
sentence.<span style="">subjects</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: grey;"># List of NP-SBJ chunks.</span><br />
sentence.<span style="">objects</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: grey;"># List of NP-OBJ chunks.</span><br />
sentence.<span style="">verbs</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: grey;"># List of VP chunks.</span><br />
sentence.<span style="">relations</span> &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: grey;"># {'SBJ': {1: Chunk('the cat/NP-SBJ-1')},</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: grey;"># &nbsp; 'VP': {1: Chunk('sat/VP-1')},</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: grey;"># &nbsp;'OBJ': {}}</span><br />
sentence.<span style="">pnp</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: grey;"># List of PNPChunks: [Chunk('on the mat/PNP')]</span></code></span></p>
<p><span class="geshifilter"><code class="python geshifilter-python">sentence.<span style="">constituents</span><span style="">&#40;</span>pnp=<span style="color: #4a587c;">False</span><span style="">&#41;</span></code></span></p>
<p><span class="geshifilter"><code class="python geshifilter-python">sentence.<span style="color: #4a587c;">slice</span><span style="">&#40;</span>start, stop<span style="">&#41;</span><br />
sentence.<span style="">copy</span><span style="">&#40;</span><span style="">&#41;</span><br />
sentence.<span style="">xml</span></code></span></p>
<ul>
<li><span class="inline_code">Sentence.constituents()</span> returns an in-order list of <span class="inline_code">Word</span> and <span class="inline_code">Chunk</span> objects.<br />With <span class="inline_code">pnp=True</span>, also groups into&nbsp;<span class="inline_code">PNPChunk</span> objects whenever possible.</li>
<li><span class="inline_code">Sentence.slice() </span>returns a <span class="inline_code">Slice</span> (subclass of <span class="inline_code">Sentence</span>) starting with the word at index <span class="inline_code">start</span> and containing all the words up to (before) index <span class="inline_code">stop</span>.</li>
</ul>
<h3>Sentence words</h3>
<p>A <span class="inline_code">Sentence</span> is made up of <span class="inline_code">Word</span> objects, which are also grouped in <span class="inline_code">Chunk</span> objects:</p>
<p><span class="geshifilter"><code class="python geshifilter-python">word = Word<span style="">&#40;</span>sentence, <span style="">string</span>, lemma=<span style="color: #4a587c;">None</span>, type=<span style="color: #4a587c;">None</span>, index=<span style="color: #666;">0</span><span style="">&#41;</span></code></span><span class="geshifilter"><code class="python geshifilter-python">word.<span style="">sentence</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: grey;"># Sentence parent.</span><br />
word.<span style="">index</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: grey;"># Sentence index of word.</span><br />
word.<span style="">string</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: grey;"># String (Unicode).</span><br />
word.<span style="">lemma</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: grey;"># String lemma, e.g. 'sat' =&gt; 'sit',</span><br />
word.<span style="">type</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: grey;"># Part-of-speech tag (NN, JJ, VBD, ...)</span><br />
word.<span style="">chunk</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: grey;"># Chunk parent, or None.</span><br />
word.<span style="">pnp</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: grey;"># PNPChunk parent, or None.</span></code></span></p>
<h3>Sentence chunks</h3>
<p>A <span class="inline_code">Chunk</span> is a list of <span class="inline_code">Word</span> objects that belong together. <br />Chunks can be part of a <span class="inline_code">PNPChunk</span>, which starts with a <span class="postag">PP</span> chunk followed by <span class="postag">NP</span> chunks.</p>
<p><span class="geshifilter"><code class="python geshifilter-python"><span style="">chunk</span> = Chunk<span style="">&#40;</span>sentence, words=<span style="">&#91;</span><span style="">&#93;</span>, type=<span style="color: #4a587c;">None</span>, role=<span style="color: #4a587c;">None</span>, relation=<span style="color: #4a587c;">None</span><span style="">&#41;</span></code></span><span class="geshifilter"><code class="python geshifilter-python"><span style="">chunk</span>.<span style="">sentence</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: grey;"># Sentence parent.</span><br />
<span style="">chunk</span>.<span style="">start</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: grey;"># Sentence index of first word.</span><br />
<span style="">chunk</span>.<span style="">stop</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: grey;"># Sentence index of last word + 1.</span><br />
<span style="">chunk</span>.<span style="">string</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: grey;"># String of words (Unicode).</span><br />
<span style="">chunk</span>.<span style="">words</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: grey;"># List of Word objects.</span><br />
<span style="">chunk</span>.<span style="">head</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: grey;"># Primary Word in the chunk.</span><br />
<span style="">chunk</span>.<span style="">type</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: grey;"># Chunk tag (NP, VP, PP, ...)</span><br />
<span style="">chunk</span>.<span style="">role</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: grey;"># Role tag (SBJ, OBJ, ...)</span><br />
<span style="">chunk</span>.<span style="">relation</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: grey;"># Relation id, e.g. NP-SBJ-1 =&gt; 1.</span><br />
<span style="">chunk</span>.<span style="">relations</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: grey;"># List of (id, role)-tuples.</span><br />
<span style="">chunk</span>.<span style="">related</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: grey;"># List of Chunks with same relation id.</span><br />
<span style="">chunk</span>.<span style="">subject</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: grey;"># NP-SBJ chunk with same id.</span><br />
<span style="">chunk</span>.<span style="color: #4a587c;">object</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: grey;"># NP-OBJ chunk with same id.</span><br />
<span style="">chunk</span>.<span style="">verb</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: grey;"># VP chunk with same id.</span><br />
<span style="">chunk</span>.<span style="">modifiers</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: grey;"># []</span><br />
<span style="">chunk</span>.<span style="">conjunctions</span> &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: grey;"># []</span><br />
<span style="">chunk</span>.<span style="">pnp</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: grey;"># PNPChunk parent, or None.</span></code></span></p>
<p><span class="geshifilter"><code class="python geshifilter-python"><span style="">chunk</span>.<span style="">previous</span><span style="">&#40;</span>type=<span style="color: #4a587c;">None</span><span style="">&#41;</span><br />
<span style="">chunk</span>.<span style="">next</span><span style="">&#40;</span>type=<span style="color: #4a587c;">None</span><span style="">&#41;</span><br />
<span style="">chunk</span>.<span style="">nearest</span><span style="">&#40;</span>type=<span style="color: #657a8a;">'VP'</span><span style="">&#41;</span></code></span></p>
<ul>
<li><span class="inline_code">Chunk.head</span> yields the last (i.e. primary) <span class="inline_code">Word</span> in the chunk: <em>the big cat</em> → <em>cat</em>.</li>
<li><span class="inline_code">Chunk.relations</span><span class="inline_code">&nbsp;</span> contains <em>all</em> relations the chunk is involved in. <br />Some chunks have multiple relations, for example functioning as both <span class="postag">SBJ</span> and <span class="postag">OBJ</span>, or being the <span class="postag">OBJ</span> of multiple <span class="postag">VP</span> chunks. </li>
<li>For <span class="postag">VP</span> chunks, <span class="inline_code">Chunk.modifiers</span> is a list of nearby adjectives and adverbs with no relations. <br />For example in <em>the cat really wants out</em>: <em>really</em> and <em>out</em> are <span class="postag">ADVP</span> with no relations. <br />The parse tree will assume that they have something to do with the <span class="postag">VP</span> <em>wants</em>. <br />What does the cat want? → <em>out</em>. <br />How badly does the cat want out? → <em>really</em>.</li>
<li><span class="inline_code">Chunk.conjunctions</span> is a list of chunks linked by <em>and</em> &amp; <em>or</em> to this chunk. <br />For example in <em>going up and down</em>: the <em>up</em> chunk has conjunctions: <span class="inline_code">[(Chunk('down'), AND)] </span></li>
</ul>
<h3>Prepositional noun phrases</h3>
<p><span class="inline_code">PNPChunk</span> is a subclass of <span class="inline_code">Chunk</span>. It has the same attributes and methods. <br />It groups <span class="postag">PP</span> + <span class="postag">NP</span> chunks in a prepositional noun phrase (<span class="postag">PNP</span>).</p>
<p><span class="geshifilter"><code class="python geshifilter-python">pnp = PNPChunk<span style="">&#40;</span>sentence, words=<span style="">&#91;</span><span style="">&#93;</span>, type=<span style="color: #4a587c;">None</span>, role=<span style="color: #4a587c;">None</span>, relation=<span style="color: #4a587c;">None</span><span style="">&#41;</span></code></span><span class="geshifilter"><code class="python geshifilter-python">pnp.<span style="">string</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: grey;"># String of words (Unicode).</span><br />
pnp.<span style="">chunks</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: grey;"># List of Chunk objects.</span><br />
pnp.<span style="">preposition</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: grey;"># First PP-chunk in the PNP.</span></code></span></p>
<p>Words and chunks that are part of a <span class="postag">PNP</span> will have their <span class="inline_code">Word.pnp</span> and <span class="inline_code">Chunk.pnp</span> attribute set.<br />All the prepositional noun phrases in a sentence can be retrieved with <span class="inline_code">Sentence.pnp</span>.</p>
<p>&nbsp;</p>
<h2>
<hr /><a name="sentiment"></a>Sentiment</h2>
<p>Text can be broadly categorized into two types: facts and opinions. Opinions carry people's sentiments, appraisals and feelings toward the world. The module bundles a lexicon of adjectives that occur frequently in product reviews, tagged with scores for sentiment polarity (positive/negative) and subjectivity.&nbsp;</p>
<p>The <span class="inline_code">sentiment()</span> command returns a (<span class="inline_code">polarity</span>, <span class="inline_code">subjectivity</span>)-tuple for the given sentence (based on the adjectives in it),&nbsp;with polarity between <span class="inline_code">-1.0</span> and <span class="inline_code">1.0</span> and subjectivity between <span class="inline_code">0.0</span> and <span class="inline_code">1.0</span>.&nbsp;The sentence can be a string, <span class="inline_code">Text</span>, <span class="inline_code">Sentence</span>, <span class="inline_code">Chunk</span>,&nbsp;<span class="inline_code">Word</span> or a&nbsp;<span class="inline_code">Synset</span> (see further).</p>
<p><span class="geshifilter"><code class="python geshifilter-python">sentiment<span style="">&#40;</span>sentence<span style="">&#41;</span></code></span><span class="geshifilter"><code class="python geshifilter-python">polarity<span style="">&#40;</span>sentence<span style="">&#41;</span></code></span><span class="geshifilter"><code class="python geshifilter-python">subjectivity<span style="">&#40;</span>sentence<span style="">&#41;</span></code></span><span class="geshifilter"><code class="python geshifilter-python">positive<span style="">&#40;</span>s, threshold=<span style="color: #666;">0.1</span><span style="">&#41;</span></code></span></p>
<p><span class="example"><span class="geshifilter"><code class="python geshifilter-python"><span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">from</span> pattern.<span style="">en</span> <span style="color: #28334f; font-weight: bold;">import</span> sentiment<br />
<span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">print</span> sentiment<span style="">&#40;</span><br />
<span style="">&gt;&gt;&gt;</span> &nbsp; &nbsp; <span style="color: #657a8a;">&quot;The movie attempts to be surreal by incorporating various time paradoxes,&quot;</span><br />
<span style="">&gt;&gt;&gt;</span> &nbsp; &nbsp; <span style="color: #657a8a;">&quot;but it's presented in such a ridiculous way it's seriously boring.&quot;</span><span style="">&#41;</span> <br />
<br />
<span style="">&#40;</span>-<span style="color: #666;">0.34</span>, <span style="color: #666;">1.0</span><span style="">&#41;</span> </code></span></span></p>
<p>In the example above,&nbsp;<span class="inline_code">-0.34</span> is a compromise between <em>surreal</em>, <em>various</em>, <em>ridiculous</em> and <em>seriously boring</em>.</p>
<p>The <span class="inline_code">polarity()</span> command returns&nbsp;the sentence polarity (positive/negative sentiment).&nbsp;</p>
<p>The <span class="inline_code">subjectivity()</span> command returns the sentence subjectivity (objective/subjective).</p>
<p>The <span class="inline_code">positive()</span> command returns&nbsp;<span class="inline_code">True</span> if the given sentence's polarity is above the threshold. The threshold can be lowered or raised, but overall&nbsp;<span class="inline_code">+0.1</span> gives the best results for product reviews. Accuracy is 72% (P 0.72, R 0.71) for movie reviews.</p>
<p>&nbsp;</p>
<h2>
<hr /></h2>
<h2><a name="modality"></a>Mood &amp; modality</h2>
<p>Linguistic modality deals with necessity, permissibility and probability. This area is beyond the scope of the module, but we offer three interesting commands that are capable of making an educated guess:</p>
<p><span class="geshifilter"><code class="python geshifilter-python">mood<span style="">&#40;</span>sentence<span style="">&#41;</span> <span style="color: grey;"># INDICATIVE | IMPERATIVE | CONDITIONAL | SUBJUNCTIVE</span></code></span><span class="geshifilter"><code class="python geshifilter-python">modality<span style="">&#40;</span>sentence, type=EPISTEMIC<span style="">&#41;</span></code></span><span class="geshifilter"><code class="python geshifilter-python">negated<span style="">&#40;</span>sentence<span style="">&#41;</span></code></span></p>
<p>The <span class="inline_code">mood()</span> command tries to identify a <span class="inline_code">Sentence</span> as indicative, imperative, conditional or subjunctive:</p>
<table class="border">
<tbody>
<tr>
<td><span class="smallcaps">Mood</span></td>
<td><span class="smallcaps">Form</span></td>
<td><span class="smallcaps">Use</span></td>
<td><span class="smallcaps">Example</span></td>
</tr>
<tr>
<td><span class="inline_code">INDICATIVE</span></td>
<td>none of the below&nbsp;</td>
<td>fact, belief</td>
<td><em>It is raining.</em></td>
</tr>
<tr>
<td><span class="inline_code">IMPERATIVE</span></td>
<td>infinitive without <em>to</em></td>
<td>warning, instruction</td>
<td><em>Do your homework!</em></td>
</tr>
<tr>
<td><span class="inline_code">CONDITIONAL</span></td>
<td>would|could|should, will|can + <em>if</em></td>
<td>possible or imaginary</td>
<td><em>I could show you.</em></td>
</tr>
<tr>
<td><span class="inline_code">SUBJUNCTIVE</span></td>
<td>wish|were, <em>it is</em> + infinitive</td>
<td>wish, judgement, opinion</td>
<td><em>I wish I knew.</em></td>
</tr>
</tbody>
</table>
<p>The <span class="inline_code">mood()</span> command has an optional&nbsp;<span style="font-family: Courier, monospace; font-size: 12px;">predictive=True</span>&nbsp;parameter that determines how conditional sentences are handled.&nbsp;When&nbsp;<span class="inline_code" style="font-family: Courier, monospace; font-size: 12px;">False</span>, sentences with will/shall&nbsp;must have&nbsp;an explicit if/when/once clause in order to be identified as conditional. For example:&nbsp;while&nbsp;<em>"You will help me"</em>&nbsp;is imperative,&nbsp;<em>"I will help you"</em>&nbsp;is predictive conditional and "<em>I will help you when I get back"</em>&nbsp;is speculative conditional.&nbsp;Sentences with can/may always need an explicit if-clause.</p>
<p>The <span class="inline_code">modality()</span> command returns a value between <span class="inline_code">-1.0</span> and +<span class="inline_code">1.0</span>, expressing the degree of possibility:&nbsp;<em>"I wish it would stop raining"</em> scores <span class="inline_code">-0.35</span> whereas <em>"It will surely stop raining"</em> scores <span class="inline_code">+0.75</span>. Roughly,&nbsp;<span class="inline_code">&gt;=0.9</span> can be seen as certain, and&nbsp;<span class="inline_code">&lt;=0.5</span> as uncertain (in varying degrees). Accuracy (F1-score) is around 89% for biomedical texts and 49% for Wikipedia texts.</p>
<p>The <span class="inline_code">negated()</span> command returns <span class="inline_code">True</span> if the <span class="inline_code">Sentence</span> contains <em>never</em>, <em>not</em> or <em>n't</em> (as in <em>would<span style="text-decoration: underline;">n't</span></em>).</p>
<p>&nbsp;</p>
<hr />
<h2><a name="wordnet"></a>WordNet</h2>
<p>The <span class="inline_code">pattern.en</span> module comes bundled with WordNet 3.0 and Oliver Steele's PyWordNet module. <a href="http://wordnet.princeton.edu/" target="_blank">WordNet</a> is a lexical database for the English language, that groups words into <span class="inline_code">Synset</span> objects (= sets of synonyms). Each synset provides a short definition and various semantic relations to other synsets:</p>
<p><span class="geshifilter"><code class="python geshifilter-python">synset = synsets<span style="">&#40;</span>word, pos=NOUN<span style="">&#41;</span><span style="">&#91;</span>i<span style="">&#93;</span></code></span><span class="geshifilter"><code class="python geshifilter-python">synset.<span style="">pos</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: grey;"># Part-of-speech: NOUN | VERB | ADJECTIVE | ADVERB.</span><br />
synset.<span style="">synonyms</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: grey;"># List of word forms (i.e. synonyms).</span><br />
synset.<span style="">gloss</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: grey;"># Definition string.</span><br />
synset.<span style="">lexname</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: grey;"># Category string, or None.</span><br />
synset.<span style="">ic</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: grey;"># Information Content value.</span><br />
synset.<span style="">weight</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: grey;"># Tuple of (polarity, subjectivity), using SentiWordNet.</span></code></span><span class="geshifilter"><code class="python geshifilter-python">synset.<span style="">antonym</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: grey;"># A Synset (semantical opposite).</span><br />
synset.<span style="">hypernym</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: grey;"># A Synset (semantical parent).</span></code></span></p>
<p><span class="geshifilter"><code class="python geshifilter-python">synset.<span style="">hypernyms</span><span style="">&#40;</span>recursive=<span style="color: #4a587c;">False</span>, depth=<span style="color: #4a587c;">None</span><span style="">&#41;</span><br />
synset.<span style="">hyponyms</span><span style="">&#40;</span>recursive=<span style="color: #4a587c;">False</span>, depth=<span style="color: #4a587c;">None</span><span style="">&#41;</span><br />
synset.<span style="">meronyms</span><span style="">&#40;</span><span style="">&#41;</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: grey;"># List of synsets (members/parts).</span><br />
synset.<span style="">holonyms</span><span style="">&#40;</span><span style="">&#41;</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: grey;"># List of synsets (of which this is a member).</span><br />
synset.<span style="">similar</span><span style="">&#40;</span><span style="">&#41;</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: grey;"># List of synsets (similar adjectives/verbs) </span></code></span></p>
<ul>
<li><span class="inline_code">Synset.hypernyms()</span> returns a list of <em>&nbsp;</em>parent synsets (i.e. more general).</li>
<li><span class="inline_code">Synset.hyponyms()</span> returns a list child synsets (i.e. more specific).<br />With <span class="inline_code">recursive=True</span>, returns all parents of all parents / all children of all children.<br />Optionally returns parents / children recursively up to the given <span class="inline_code">depth</span>.</li>
</ul>
<p>For example:</p>
<p><span class="example"><span class="geshifilter"><code class="python geshifilter-python"><span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">from</span> pattern.<span style="">en</span> <span style="color: #28334f; font-weight: bold;">import</span> wordnet<br />
<span style="">&gt;&gt;&gt;</span> s = wordnet.<span style="">synsets</span><span style="">&#40;</span><span style="color: #657a8a;">'bird'</span><span style="">&#41;</span><span style="">&#91;</span><span style="color: #666;">0</span><span style="">&#93;</span><br />
<span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">print</span> <span style="color: #657a8a;">'Definition:'</span>, s.<span style="">gloss</span><br />
<span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">print</span> <span style="color: #657a8a;">' &nbsp;Synonyms:'</span>, s.<span style="">synonyms</span><br />
<span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">print</span> <span style="color: #657a8a;">' Hypernyms:'</span>, s.<span style="">hypernyms</span><span style="">&#40;</span><span style="">&#41;</span><br />
<span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">print</span> <span style="color: #657a8a;">' &nbsp;Hyponyms:'</span>, s.<span style="">hyponyms</span><span style="">&#40;</span><span style="">&#41;</span><br />
<span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">print</span> <span style="color: #657a8a;">' &nbsp;Holonyms:'</span>, s.<span style="">holonyms</span><span style="">&#40;</span><span style="">&#41;</span><br />
<span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">print</span> <span style="color: #657a8a;">' &nbsp;Meronyms:'</span>, s.<span style="">meronyms</span><span style="">&#40;</span><span style="">&#41;</span><br />
<br />
Definition: u<span style="color: #657a8a;">'warm-blooded egg-laying vertebrates characterized <br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; by feathers and forelimbs modified as wings'</span><br />
&nbsp; Synonyms: <span style="">&#91;</span><span style="color: #657a8a;">'bird'</span><span style="">&#93;</span><br />
&nbsp;Hypernyms: <span style="">&#91;</span>Synset<span style="">&#40;</span><span style="color: #657a8a;">'vertebrate'</span><span style="">&#41;</span><span style="">&#93;</span><br />
&nbsp; Hyponyms: <span style="">&#91;</span>Synset<span style="">&#40;</span><span style="color: #657a8a;">'dickeybird'</span><span style="">&#41;</span>, Synset<span style="">&#40;</span><span style="color: #657a8a;">'cock'</span><span style="">&#41;</span>, Synset<span style="">&#40;</span><span style="color: #657a8a;">'hen'</span><span style="">&#41;</span>, ...<span style="">&#93;</span><br />
&nbsp; Holonyms: <span style="">&#91;</span>Synset<span style="">&#40;</span><span style="color: #657a8a;">'Aves'</span><span style="">&#41;</span>, Synset<span style="">&#40;</span><span style="color: #657a8a;">'flock'</span><span style="">&#41;</span><span style="">&#93;</span><br />
&nbsp; Meronyms: <span style="">&#91;</span>Synset<span style="">&#40;</span><span style="color: #657a8a;">'beak'</span><span style="">&#41;</span>, Synset<span style="">&#40;</span><span style="color: #657a8a;">'furcula'</span><span style="">&#41;</span>, Synset<span style="">&#40;</span><span style="color: #657a8a;">'feather'</span><span style="">&#41;</span>, ...<span style="">&#93;</span></code></span></span></p>
<p><span class="example"><span class="small"><span style="text-decoration: underline;">Reference</span>: Fellbaum, C. (1998). <em>WordNet: An Electronic Lexical Database</em>. Cambridge, MIT Press.</span><br /></span></p>
<h3>Synset similarity</h3>
<p>The <span class="inline_code">ancestor()</span> command returns the common ancestor (or <em>least common subsumer</em>) of two synsets.<br />The <span class="inline_code">similarity()</span> command returns the semantic similarity of two synsets, as a number.</p>
<p><span class="geshifilter"><code class="python geshifilter-python">ancestor<span style="">&#40;</span>synset1, synset2<span style="">&#41;</span></code></span></p>
<p><span class="geshifilter"><code class="python geshifilter-python">similarity<span style="">&#40;</span>synset1, synset2<span style="">&#41;</span> <span style="color: grey;"># Lower value = higher similarity.</span></code></span></p>
<p><span class="example"><span class="geshifilter"><code class="python geshifilter-python"><span style="">&gt;&gt;&gt;</span> a = wordnet.<span style="">synsets</span><span style="">&#40;</span><span style="color: #657a8a;">'cat'</span><span style="">&#41;</span><span style="">&#91;</span><span style="color: #666;">0</span><span style="">&#93;</span><br />
<span style="">&gt;&gt;&gt;</span> b = wordnet.<span style="">synsets</span><span style="">&#40;</span><span style="color: #657a8a;">'dog'</span><span style="">&#41;</span><span style="">&#91;</span><span style="color: #666;">0</span><span style="">&#93;</span><br />
<span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">print</span> wordnet.<span style="">ancestor</span><span style="">&#40;</span>a, b<span style="">&#41;</span><br />
<br />
Synset<span style="">&#40;</span><span style="color: #657a8a;">'carnivore'</span><span style="">&#41;</span></code></span></span></p>
<p><span class="example"><span class="geshifilter"><code class="python geshifilter-python"><span style="">&gt;&gt;&gt;</span> c = wordnet.<span style="">synsets</span><span style="">&#40;</span><span style="color: #657a8a;">'teapot'</span><span style="">&#41;</span><span style="">&#91;</span><span style="color: #666;">0</span><span style="">&#93;</span><br />
<span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">print</span> wordnet.<span style="">similarity</span><span style="">&#40;</span>a, b<span style="">&#41;</span><br />
<span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">print</span> wordnet.<span style="">similarity</span><span style="">&#40;</span>a, c<span style="">&#41;</span><br />
<br />
<span style="color: #666;">3.29</span><br />
<span style="color: #666;">4152.56</span></code></span></span></p>
<p>The similarity weight is based on Lin-similarity and Information Content (IC). IC values for each synset are derived from the word's occurence in a given corpus (e.g. Brown). The idea is that less frequent words convey more information. Lower values indicate higher similarity:</p>
<p><span class="inline_code">lin = 2.0 * ancestor(synset1, synset2).ic / (synset1.ic + synset2.ic)</span></p>
<h3>Synset sentiment</h3>
<p><a href="http://sentiwordnet.isti.cnr.it/" target="_blank">SentiWordNet</a> is a third-party lexical resource for opinion mining, with polarity and subjectivity scores for all WordNet synsets. SentiWordNet is free for non-commercial research purposes. To enable SentiWordNet, request a download from the authors and place the file <span class="inline_code">SentiWordNet*.txt</span> in&nbsp;<span class="inline_code">pattern/en/wordnet/</span>.&nbsp;You can then use&nbsp;<span class="inline_code">wordnet.sentiwordnet</span>&nbsp;and <span class="inline_code">Synset.weight()</span> in your script:</p>
<p><span class="example"><span class="geshifilter"><code class="python geshifilter-python"><span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">from</span> pattern.<span style="">en</span> <span style="color: #28334f; font-weight: bold;">import</span> wordnet<br />
<span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">from</span> pattern.<span style="">en</span> <span style="color: #28334f; font-weight: bold;">import</span> ADJECTIVE<br />
<span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">print</span> wordnet.<span style="">sentiwordnet</span><span style="">&#91;</span><span style="color: #657a8a;">'lamp'</span><span style="">&#93;</span><br />
<span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">print</span> wordnet.<span style="">synsets</span><span style="">&#40;</span><span style="color: #657a8a;">'happy'</span>, ADJECTIVE<span style="">&#41;</span><span style="">&#91;</span><span style="color: #666;">0</span><span style="">&#93;</span>.<span style="">weight</span><br />
<span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">print</span> wordnet.<span style="">synsets</span><span style="">&#40;</span><span style="color: #657a8a;">'sad'</span>, ADJECTIVE<span style="">&#41;</span><span style="">&#91;</span><span style="color: #666;">0</span><span style="">&#93;</span>.<span style="">weight</span><br />
<br />
<span style="">&#40;</span><span style="color: #666;">0.0</span>, <span style="color: #666;">0.0</span><span style="">&#41;</span><br />
<span style="">&#40;</span><span style="color: #666;">0.375</span>, <span style="color: #666;">0.875</span><span style="">&#41;</span><br />
<span style="">&#40;</span>-<span style="color: #666;">0.625</span>, <span style="color: #666;">0.875</span><span style="">&#41;</span></code></span></span></p>
<p>&nbsp;</p>
<hr />
<h2><a name="wordlist"></a>Wordlists</h2>
<p>The <span class="inline_code">patten.en</span> module includes a number of general-purpose word lists:</p>
<table class="border">
<tbody>
<tr>
<td><span class="smallcaps">List</span></td>
<td><span class="smallcaps">Description</span></td>
<td style="text-align: center;"><span class="smallcaps">Size</span></td>
<td><span class="smallcaps">Example</span></td>
</tr>
<tr>
<td><span class="inline_code">ACADEMIC</span></td>
<td>English academic words</td>
<td style="text-align: center;">500</td>
<td><em>criterion</em>, <em>proportionally</em>, <em>research</em></td>
</tr>
<tr>
<td><span class="inline_code">BASIC</span></td>
<td>English basic words</td>
<td style="text-align: center;">1,000</td>
<td><em>chicken</em>, <em>pain</em>, <em>road</em></td>
</tr>
<tr>
<td><span class="inline_code">PROFANITY</span></td>
<td>English swear words</td>
<td style="text-align: center;">350</td>
<td>&nbsp;</td>
</tr>
<tr>
<td><span class="inline_code">TIME</span></td>
<td>English time &amp; date words</td>
<td style="text-align: center;">100</td>
<td><em>Christmas</em>, <em>past</em>, <em>saturday</em></td>
</tr>
</tbody>
</table>
<p><span class="example"><span class="geshifilter"><code class="python geshifilter-python"><span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">from</span> pattern.<span style="">en</span>.<span style="">wordlists</span> <span style="color: #28334f; font-weight: bold;">import</span> ACADEMIC<br />
<span style="">&gt;&gt;&gt;</span> words = <span style="color: #4a587c;">open</span><span style="">&#40;</span><span style="color: #657a8a;">&quot;paper.txt&quot;</span><span style="">&#41;</span>.<span style="">read</span><span style="">&#40;</span><span style="">&#41;</span>.<span style="">split</span><span style="">&#40;</span><span style="color: #657a8a;">&quot; &quot;</span><span style="">&#41;</span><br />
<span style="">&gt;&gt;&gt;</span> words = <span style="">&#91;</span>w <span style="color: #28334f; font-weight: bold;">for</span> w <span style="color: #28334f; font-weight: bold;">in</span> words <span style="color: #28334f; font-weight: bold;">if</span> w <span style="color: #28334f; font-weight: bold;">not</span> <span style="color: #28334f; font-weight: bold;">in</span> ACADEMIC<span style="">&#93;</span> </code></span></span></p>
<p>&nbsp;</p>
<hr />
<h2>See also</h2>
<ul>
<li><a href="http://www.clips.ua.ac.be/pages/MBSP" target="_blank">MBSP</a> (GPL): r<span>obust parser using a memory-based learning approach, in Python.</span></li>
<li><span><a href="http://www.nltk.org/" target="_blank">NLTK</a> (Apache): f</span><span>ull natural language processing toolkit for Python.</span></li>
</ul>
</div>
</div></div>
        </div>
    </div>
    </div>
    </div>
    </div>
    </div>
</body>
</html>