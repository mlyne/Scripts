#!/usr/bin/perl
#
#

use strict;
use warnings;

package SynbioRegionSearch;

require Exporter;
@ISA = qw(Exporter);
@EXPORT = qw(porter);

# Set the output field separator as tab
#$, = "\t";
# Print unicode to standard out
binmode(STDOUT, 'utf8');
# Silence warnings when printing null fields
no warnings ('uninitialized');

sub regionSearch {

  my $coord = shift;
  $coord =~ m/(.+)\:/;
  $chrom = $1;

# # This code makes use of the Webservice::InterMine library.
# # The following import statement sets SynBioMine Experimental as your default
# #use Webservice::InterMine 1.0405 'http://met1:8080/synbiomine-exper';
# 
# use Webservice::InterMine::Bio::RegionQuery qw/GFF3/;
# use Webservice::InterMine 0.9904;
# 
# my $service = Webservice::InterMine->get_service('http://met1:8080/synbiomine-exper');
# my $region_query = Webservice::InterMine::Bio::RegionQuery->new(
#     service => $service,
#     organism => "E. coli str. K-12 substr. MG1655",
#     regions => ["NC_000913.2:2598423..2598460", ],
#     feature_types => ["Gene"]
# );
# 
# print "Sequence data...", "\n";
# # print $region_query->bed;
# # print $region_query->fasta;
# print $region_query->gff3;

# This code makes use of the Webservice::InterMine library.
# The following import statement sets SynBioMine Experimental as your default
use Webservice::InterMine 1.0200 'http://met1:8080/synbiomine-exper';

my $query = new_query(class => 'Chromosome');

# The view specifies the output columns
$query->add_view(qw/
    primaryIdentifier
    organism.shortName
/);

# Use an iterator to avoid having all rows in memory at once.
my $org_short;
my $it = $query->iterator();
while (my $row = <$it>) {
  $org_short = $row->{'organism.shortName'};
}

#my $test_gene = "BSU30400";
#my $org_short = "B. subtilis subsp. subtilis str. 168";
my $test_gene = "EG11149";
#my $org_short = "E. coli str. K-12 substr. MG1655";

my $query = new_query(class => 'Gene');

# The view specifies the output columns
$query->add_view(qw/
    primaryIdentifier
    organism.shortName
    expressionResults.log2FoldChange
    expressionResults.CV
    expressionResults.meanExpr
    expressionResults.condition.name
/);

# edit the line below to change the sort order:
# $query->add_sort_order('primaryIdentifier', 'ASC');

$query->add_constraint(
    path        => 'Gene',
    op          => 'LOOKUP',
    value       => "$test_gene",
    extra_value => "$org_short",
    code        => 'A',
);


# Use an iterator to avoid having all rows in memory at once.
my $it = $query->iterator();
my @results;
while (my $row = <$it>) {
  push (@results, [$row->{'primaryIdentifier'}, 
		    $row->{'organism.shortName'},
		    $row->{'expressionResults.log2FoldChange'}, 
		    $row->{'expressionResults.CV'},
		    $row->{'expressionResults.meanExpr'}, 
		    $row->{'expressionResults.condition.name'}])

#     print $row->{'primaryIdentifier'}, $row->{'organism.shortName'},
#         $row->{'expressionResults.log2FoldChange'}, $row->{'expressionResults.CV'},
#         $row->{'expressionResults.meanExpr'}, $row->{'expressionResults.condition.name'}, "\n";
}

# for my $result (@results) {
#   print join("\t", @{ $result }), "\n";
# }

  return \@results;


}
1;